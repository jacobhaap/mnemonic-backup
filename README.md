# Mnemonic Backup
> A mnemonic solution for backup/recovery codes.

Mnemonic Backup is an implementation of 14-word Mnemonic Backup Phrases, designed for use cases such as backup and recovery codes. To get started, install install the library:
```bash
npm install mnemonic-backup
```
This library consists of four functions: **generateMnemonic**, **generateKey**, **encryptMnemonic**, and **decryptMnemonic**. These functions are used in the creation of Mnemonic Backup Phrases, cryptographic keys, and for the encryption and decryption of Mnemonic Backup Phrases.

## Mnemonic Phrase Generation
The Mnemonic Phrase is generated using the `generateMnemonic`  function, entropy is used to obtain a mnemonic by mapping 11-bit segments to words in the BIP39 English wordlist from **@scure/bip39**. Entropy is either generated locally with the Node **Crypto** module's `crypto.randomBytes();` function, or supplied directly as bits. To generate a phrase, 154 bits of entropy is required, provided directly as bits. If less than 154 bits of entropy is provided, mnemonic generation will fail, while if more than 154 bits of entropy is provided, the bits are truncated to the required length. The function returns the Mnemonic Phrase in the output.
```js
const { generateMnemonic } = require('mnemonic-backup');

// 176 Bits of entropy in Hex
const hex = "596F75206A757374206C6F7374205468652047616D65";
// Obtain Bits from Hex
const entropy = hex.split('').map(char => parseInt(char, 16).toString(2).padStart(4, '0')).join('');

const mnemonic = generateMnemonic(entropy);
console.log("Mnemonic Phrase:", mnemonic);

// Function Output 
// Mnemonic Phrase: floor knife elite stay fire ring like mistake inflict patient bench speak faith casual

```

## Obtaining a Cryptographic Key
A Cryptographic Key is derived from the last word of the 14 word Mnemonic Phrase using the **PBKDF2** (Password-Based Key Derivation Function 2) key derivation function:
```js
crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)
```
In this setup, the last word of the Mnemonic Phrase is supplied as the `password`, and a base58 (**@scure/base**) encoding of the first 13 words of the Mnemonic Phrase is used as the `salt`. By default, the number of iterations is *210,000* based on the [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2) recommendations for **PBKDF2-HMAC-SHA512**. The requested byte length of the key (`keylen`) is set to *32*, and the `digest` is set to *SHA512*.

### Example Use
To generate the Cryptographic Key, the `generateKey` function is used. This function requires a `mnemonic` (Mnemonic Phrase) be supplied, and optionally allows a number of `iterations` to be specified, using the default value if not specified. The function returns the Cryptographic Key in the output.
```js
const { generateKey } = require('mnemonic-backup');

// 14 Word Mnemonic Phrase
const mnemonic = "floor knife elite stay fire ring like mistake inflict patient bench speak faith casual";

generateKey(mnemonic)
    .then((key) => {
        console.log("Cryptographic Key:", key);
    });

// Function Output
// Cryptographic Key: 1b0b26d1325109b4b2235c83960c185d8651633523d95e33f6f1551299ec7b68

```

## Encrypting the Mnemonic Phrase (Creating a Cypher)
A cypher is created by encrypting the Mnemonic Phrase with **AES** (Advanced Encryption Standard) at a length of 256 bits using **GCM** (Galois/Counter Mode):
```js
crypto.createCipheriv(algorithm, key, iv[, options])
```
In this setup, the `algorithm` is *aes-256-gcm*, with the `key` being the Cryptographic Key generated from the last word of the Mnemonic Phrase from the `generateKey` function. By default, the Initialization Vector (`iv`) is a Buffer of 12 randomly generated bytes with `crypto.randomBytes(12)`. The Mnemonic Phrase is then encrypted using `.update(mnemonic, 'utf8', 'hex')`, and an Authentication Tag is returned with `.getAuthTag().toString('hex')`.

### Example Use
To encrypt the Mnemonic Phrase/create a cypher, the `encryptMnemonic` function is used. This function requires a `mnemonic` (Mnemonic Phrase), and a `key` (Cryptographic Key) be supplied, and optionally allows an Initialization Vector (`iv`) be set, using the default random generation if not specified. The Initialization Vector may be a *UTF-8* encoded string, *Buffer*, *TypedArray*, or *DataView*. The function returns the *cyphertext* (cypher/encrypted Mnemonic Phrase), *authTag* (Authentication Tag), and Initialization Vector in the output.
```js
const { encryptMnemonic } = require('mnemonic-backup');

// 14 Word Mnemonic Phrase
const mnemonic = "floor knife elite stay fire ring like mistake inflict patient bench speak faith casual";

// Cryptographic Key
const key = "1b0b26d1325109b4b2235c83960c185d8651633523d95e33f6f1551299ec7b68";

// Initialization Vector from Buffer
const iv = Buffer.from([0x44, 0x49, 0x4E, 0x4F, 0x53, 0x41, 0x55, 0x52]);

const result = encryptMnemonic(mnemonic, key, iv);
    console.log("Cyphertext:", result.cyphertext);
    console.log("IV:", result.iv);
    console.log("Auth Tag:", result.authTag);

// Function Output
// Cyphertext: ce64299d0c57881673bed10795d266d3c323c4b5ca76ebb0a74911ee76e34923f3fc320de23a5f2d21bd9556545685e9e6a9088cf099eb0ba17293e4971a8540dcad545e015057682188a787142bc4
// IV: 44494e4f53415552
// Auth Tag: ec5982a22ac3fa69156f2bea5409720a

```

## Decryption
A cypher/encrypted Mnemonic Phrase is decrypted using the *cyphertext* and *authTag* from the encryption output, along with the same Cryptographic Key and Initialization Vector used for encryption:
```js
crypto.createDecipheriv(algorithm, key, iv[, options])
```
The `algorithm` used for decryption is the same used for encryption, *aes-256-gcm*. The `key` is the Cryptographic Key, `iv` is the Initialization Vector. The Authentication Tag (*authTag*) is set using `setAuthTag(Buffer.from(authTag, 'hex'))`.

### Example Use
To decrypt a cypher/encrypted Mnemonic Phrase, the `decryptMnemonic` function is used. This function requires a `cyphertext` (the *cyphertext* from the encryption), `key` (Cryptographic Key), `iv` (Initialization Vector), and  `authTag` (Authentication Tag) be supplied. The function returns the decrypted Mnemonic Phrase (without the last word) in the output.
```js
const { decryptMnemonic } = require('mnemonic-backup');

// Cryptographic Key
const key = "1b0b26d1325109b4b2235c83960c185d8651633523d95e33f6f1551299ec7b68";

// cyphertext, iv, and authTag from Encryption
const cyphertext = "ce64299d0c57881673bed10795d266d3c323c4b5ca76ebb0a74911ee76e34923f3fc320de23a5f2d21bd9556545685e9e6a9088cf099eb0ba17293e4971a8540dcad545e015057682188a787142bc4";
const iv = "44494e4f53415552";
const authTag = "ec5982a22ac3fa69156f2bea5409720a";

const decryptedMnemonic = decryptMnemonic(cyphertext, key, iv, authTag);
console.log("Decrypted Mnemonic:", decryptedMnemonic);

// Function Output
// Decrypted Mnemonic: floor knife elite stay fire ring like mistake inflict patient bench speak faith

```

## Example Use Case of the `mnemonic-backup` Library
One example use case for this library is in the generation and verification of Mnemonic Backup Phrases, such as for account recovery in a user account system. In such a system, after the mnemonic is generated, the *cyphertext*, *iv*, and *authTag* from the encryption might be securely stored (e.g., in the user data), while the mnemonic is returned to the user. When verifying a Mnemonic Backup Phrase (during account recovery), the phrase can be accepted as input, regenerating the Cryptographic Key to use in decryption. If the decryption is successful (indicating that the user supplied the correct phrase), the first 13 words of the phrase are returned and can be compared with the first 13 words of the user-provided phrase. A successful match between the user-provided phrase and the decrypted phrase should act as verification that the correct Mnemonic Backup Phrase was provided, allowing the next steps of account recovery to begin.
